{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Header = exports.keySignatureKeys = void 0;\nvar BinarySearch_1 = require(\"./BinarySearch\");\nvar privatePPQMap = new WeakMap();\n/**\n * @hidden\n */\nexports.keySignatureKeys = [\"Cb\", \"Gb\", \"Db\", \"Ab\", \"Eb\", \"Bb\", \"F\", \"C\", \"G\", \"D\", \"A\", \"E\", \"B\", \"F#\", \"C#\"];\n/**\n * The parsed MIDI file header.\n */\nvar Header = /** @class */function () {\n  function Header(midiData) {\n    var _this = this;\n    /**\n     * The array of all the tempo events.\n     */\n    this.tempos = [];\n    /**\n     * The time signatures.\n     */\n    this.timeSignatures = [];\n    /**\n     * The time signatures.\n     */\n    this.keySignatures = [];\n    /**\n     * Additional meta events.\n     */\n    this.meta = [];\n    /**\n     * The name of the MIDI file;\n     */\n    this.name = \"\";\n    // Look through all the tracks for tempo changes.\n    privatePPQMap.set(this, 480);\n    if (midiData) {\n      privatePPQMap.set(this, midiData.header.ticksPerBeat);\n      // Check time signature and tempo events from all of the tracks.\n      midiData.tracks.forEach(function (track) {\n        track.forEach(function (event) {\n          if (event.meta) {\n            if (event.type === \"timeSignature\") {\n              _this.timeSignatures.push({\n                ticks: event.absoluteTime,\n                timeSignature: [event.numerator, event.denominator]\n              });\n            } else if (event.type === \"setTempo\") {\n              _this.tempos.push({\n                bpm: 60000000 / event.microsecondsPerBeat,\n                ticks: event.absoluteTime\n              });\n            } else if (event.type === \"keySignature\") {\n              _this.keySignatures.push({\n                key: exports.keySignatureKeys[event.key + 7],\n                scale: event.scale === 0 ? \"major\" : \"minor\",\n                ticks: event.absoluteTime\n              });\n            }\n          }\n        });\n      });\n      // Check the first track for other relevant data.\n      var firstTrackCurrentTicks_1 = 0; // Used for absolute times.\n      midiData.tracks[0].forEach(function (event) {\n        firstTrackCurrentTicks_1 += event.deltaTime;\n        if (event.meta) {\n          if (event.type === \"trackName\") {\n            _this.name = event.text;\n          } else if (event.type === \"text\" || event.type === \"cuePoint\" || event.type === \"marker\" || event.type === \"lyrics\") {\n            _this.meta.push({\n              text: event.text,\n              ticks: firstTrackCurrentTicks_1,\n              type: event.type\n            });\n          }\n        }\n      });\n      this.update();\n    }\n  }\n  /**\n   * This must be invoked after any changes are made to the tempo array\n   * or the timeSignature array for the updated values to be reflected.\n   */\n  Header.prototype.update = function () {\n    var _this = this;\n    var currentTime = 0;\n    var lastEventBeats = 0;\n    // Make sure it's sorted;\n    this.tempos.sort(function (a, b) {\n      return a.ticks - b.ticks;\n    });\n    this.tempos.forEach(function (event, index) {\n      var lastBPM = index > 0 ? _this.tempos[index - 1].bpm : _this.tempos[0].bpm;\n      var beats = event.ticks / _this.ppq - lastEventBeats;\n      var elapsedSeconds = 60 / lastBPM * beats;\n      event.time = elapsedSeconds + currentTime;\n      currentTime = event.time;\n      lastEventBeats += beats;\n    });\n    this.timeSignatures.sort(function (a, b) {\n      return a.ticks - b.ticks;\n    });\n    this.timeSignatures.forEach(function (event, index) {\n      var lastEvent = index > 0 ? _this.timeSignatures[index - 1] : _this.timeSignatures[0];\n      var elapsedBeats = (event.ticks - lastEvent.ticks) / _this.ppq;\n      var elapsedMeasures = elapsedBeats / lastEvent.timeSignature[0] / (lastEvent.timeSignature[1] / 4);\n      lastEvent.measures = lastEvent.measures || 0;\n      event.measures = elapsedMeasures + lastEvent.measures;\n    });\n  };\n  /**\n   * Convert ticks into seconds based on the tempo changes.\n   */\n  Header.prototype.ticksToSeconds = function (ticks) {\n    // Find the relevant position.\n    var index = (0, BinarySearch_1.search)(this.tempos, ticks);\n    if (index !== -1) {\n      var tempo = this.tempos[index];\n      var tempoTime = tempo.time;\n      var elapsedBeats = (ticks - tempo.ticks) / this.ppq;\n      return tempoTime + 60 / tempo.bpm * elapsedBeats;\n    } else {\n      // Assume 120.\n      var beats = ticks / this.ppq;\n      return 60 / 120 * beats;\n    }\n  };\n  /**\n   * Convert ticks into measures based off of the time signatures.\n   */\n  Header.prototype.ticksToMeasures = function (ticks) {\n    var index = (0, BinarySearch_1.search)(this.timeSignatures, ticks);\n    if (index !== -1) {\n      var timeSigEvent = this.timeSignatures[index];\n      var elapsedBeats = (ticks - timeSigEvent.ticks) / this.ppq;\n      return timeSigEvent.measures + elapsedBeats / (timeSigEvent.timeSignature[0] / timeSigEvent.timeSignature[1]) / 4;\n    } else {\n      return ticks / this.ppq / 4;\n    }\n  };\n  Object.defineProperty(Header.prototype, \"ppq\", {\n    /**\n     * The number of ticks per quarter note.\n     */\n    get: function () {\n      return privatePPQMap.get(this);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Convert seconds to ticks based on the tempo events.\n   */\n  Header.prototype.secondsToTicks = function (seconds) {\n    // Find the relevant position.\n    var index = (0, BinarySearch_1.search)(this.tempos, seconds, \"time\");\n    if (index !== -1) {\n      var tempo = this.tempos[index];\n      var tempoTime = tempo.time;\n      var elapsedTime = seconds - tempoTime;\n      var elapsedBeats = elapsedTime / (60 / tempo.bpm);\n      return Math.round(tempo.ticks + elapsedBeats * this.ppq);\n    } else {\n      // Assume 120.\n      var beats = seconds / (60 / 120);\n      return Math.round(beats * this.ppq);\n    }\n  };\n  /**\n   * Convert the header into an object.\n   */\n  Header.prototype.toJSON = function () {\n    return {\n      keySignatures: this.keySignatures,\n      meta: this.meta,\n      name: this.name,\n      ppq: this.ppq,\n      tempos: this.tempos.map(function (t) {\n        return {\n          bpm: t.bpm,\n          ticks: t.ticks\n        };\n      }),\n      timeSignatures: this.timeSignatures\n    };\n  };\n  /**\n   * Parse a header json object.\n   */\n  Header.prototype.fromJSON = function (json) {\n    this.name = json.name;\n    // Clone all the attributes.\n    this.tempos = json.tempos.map(function (t) {\n      return Object.assign({}, t);\n    });\n    this.timeSignatures = json.timeSignatures.map(function (t) {\n      return Object.assign({}, t);\n    });\n    this.keySignatures = json.keySignatures.map(function (t) {\n      return Object.assign({}, t);\n    });\n    this.meta = json.meta.map(function (t) {\n      return Object.assign({}, t);\n    });\n    privatePPQMap.set(this, json.ppq);\n    this.update();\n  };\n  /**\n   * Update the tempo of the midi to a single tempo. Will remove and replace\n   * any other tempos currently set and update all of the event timing.\n   * @param bpm The tempo in beats per second.\n   */\n  Header.prototype.setTempo = function (bpm) {\n    this.tempos = [{\n      bpm: bpm,\n      ticks: 0\n    }];\n    this.update();\n  };\n  return Header;\n}();\nexports.Header = Header;","map":{"version":3,"names":["BinarySearch_1","require","privatePPQMap","WeakMap","exports","keySignatureKeys","Header","midiData","_this","tempos","timeSignatures","keySignatures","meta","name","set","header","ticksPerBeat","tracks","forEach","track","event","type","push","ticks","absoluteTime","timeSignature","numerator","denominator","bpm","microsecondsPerBeat","key","scale","firstTrackCurrentTicks_1","deltaTime","text","update","prototype","currentTime","lastEventBeats","sort","a","b","index","lastBPM","beats","ppq","elapsedSeconds","time","lastEvent","elapsedBeats","elapsedMeasures","measures","ticksToSeconds","search","tempo","tempoTime","ticksToMeasures","timeSigEvent","Object","defineProperty","get","secondsToTicks","seconds","elapsedTime","Math","round","toJSON","map","t","fromJSON","json","assign","setTempo"],"sources":["/Users/niko/Documents/PAL-Imperator/node_modules/@tonejs/midi/src/Header.ts"],"sourcesContent":["import type { MidiData, MidiEvent } from \"midi-file\";\nimport { search } from \"./BinarySearch\";\n\nconst privatePPQMap = new WeakMap<Header, number>();\n\nexport interface TempoEvent {\n\tticks: number;\n\tbpm: number;\n\ttime?: number;\n}\n\nexport interface TimeSignatureEvent {\n\tticks: number;\n\ttimeSignature: number[];\n\tmeasures?: number;\n}\n\nexport interface MetaEvent {\n\ttext: string;\n\ttype: string;\n\tticks: number;\n}\n\nexport interface KeySignatureEvent {\n\tticks: number;\n\tkey: string;\n\tscale: string;\n}\n\n/**\n * @hidden\n */\nexport const keySignatureKeys = [\n\t\"Cb\",\n\t\"Gb\",\n\t\"Db\",\n\t\"Ab\",\n\t\"Eb\",\n\t\"Bb\",\n\t\"F\",\n\t\"C\",\n\t\"G\",\n\t\"D\",\n\t\"A\",\n\t\"E\",\n\t\"B\",\n\t\"F#\",\n\t\"C#\",\n];\n\n/**\n * The parsed MIDI file header.\n */\nexport class Header {\n\t/**\n\t * The array of all the tempo events.\n\t */\n\ttempos: TempoEvent[] = [];\n\n\t/**\n\t * The time signatures.\n\t */\n\ttimeSignatures: TimeSignatureEvent[] = [];\n\n\t/**\n\t * The time signatures.\n\t */\n\tkeySignatures: KeySignatureEvent[] = [];\n\n\t/**\n\t * Additional meta events.\n\t */\n\tmeta: MetaEvent[] = [];\n\n\t/**\n\t * The name of the MIDI file;\n\t */\n\tname = \"\";\n\n\tconstructor(midiData?: MidiData) {\n\t\t// Look through all the tracks for tempo changes.\n\t\tprivatePPQMap.set(this, 480);\n\n\t\tif (midiData) {\n\t\t\tprivatePPQMap.set(this, midiData.header.ticksPerBeat);\n\t\t\t\n\t\t\t// Check time signature and tempo events from all of the tracks.\n\t\t\tmidiData.tracks.forEach(track => {\n\t\t\t\ttrack.forEach((event: MidiEvent & { absoluteTime: number; meta?: boolean; }) => {\n\t\t\t\t\tif (event.meta) {\n\t\t\t\t\t\tif (event.type === \"timeSignature\") {\n\t\t\t\t\t\t\tthis.timeSignatures.push({\n\t\t\t\t\t\t\t\tticks: event.absoluteTime,\n\t\t\t\t\t\t\t\ttimeSignature: [\n\t\t\t\t\t\t\t\t\tevent.numerator,\n\t\t\t\t\t\t\t\t\tevent.denominator,\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else if (event.type === \"setTempo\") {\n\t\t\t\t\t\t\tthis.tempos.push({\n\t\t\t\t\t\t\t\tbpm: 60000000 / event.microsecondsPerBeat,\n\t\t\t\t\t\t\t\tticks: event.absoluteTime,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else if (event.type === \"keySignature\") {\n\t\t\t\t\t\t\tthis.keySignatures.push({\n\t\t\t\t\t\t\t\tkey: keySignatureKeys[event.key + 7],\n\t\t\t\t\t\t\t\tscale: event.scale === 0 ? \"major\" : \"minor\",\n\t\t\t\t\t\t\t\tticks: event.absoluteTime,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// Check the first track for other relevant data.\n\t\t\tlet firstTrackCurrentTicks = 0; // Used for absolute times.\n\t\t\tmidiData.tracks[0].forEach((event: MidiEvent & { meta?: boolean; }) => {\n\t\t\t\tfirstTrackCurrentTicks += event.deltaTime;\n\n\t\t\t\tif (event.meta) {\n\t\t\t\t\tif (event.type === \"trackName\") {\n\t\t\t\t\t\tthis.name = event.text;\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tevent.type === \"text\" ||\n\t\t\t\t\t\tevent.type === \"cuePoint\" ||\n\t\t\t\t\t\tevent.type === \"marker\" ||\n\t\t\t\t\t\tevent.type === \"lyrics\"\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.meta.push({\n\t\t\t\t\t\t\ttext: event.text,\n\t\t\t\t\t\t\tticks: firstTrackCurrentTicks,\n\t\t\t\t\t\t\ttype: event.type,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.update();\n\t\t}\n\t}\n\n\t/**\n\t * This must be invoked after any changes are made to the tempo array\n\t * or the timeSignature array for the updated values to be reflected.\n\t */\n\tupdate(): void {\n\t\tlet currentTime = 0;\n\t\tlet lastEventBeats = 0;\n\n\t\t// Make sure it's sorted;\n\t\tthis.tempos.sort((a, b) => a.ticks - b.ticks);\n\t\tthis.tempos.forEach((event, index) => {\n\t\t\tconst lastBPM =\n\t\t\t\tindex > 0 ? this.tempos[index - 1].bpm : this.tempos[0].bpm;\n\t\t\tconst beats = event.ticks / this.ppq - lastEventBeats;\n\t\t\tconst elapsedSeconds = (60 / lastBPM) * beats;\n\n\t\t\tevent.time = elapsedSeconds + currentTime;\n\t\t\tcurrentTime = event.time;\n\t\t\tlastEventBeats += beats;\n\t\t});\n\n\t\tthis.timeSignatures.sort((a, b) => a.ticks - b.ticks);\n\t\tthis.timeSignatures.forEach((event, index) => {\n\t\t\tconst lastEvent =\n\t\t\t\tindex > 0\n\t\t\t\t\t? this.timeSignatures[index - 1]\n\t\t\t\t\t: this.timeSignatures[0];\n\n\t\t\tconst elapsedBeats = (event.ticks - lastEvent.ticks) / this.ppq;\n\t\t\tconst elapsedMeasures =\n\t\t\t\telapsedBeats /\n\t\t\t\tlastEvent.timeSignature[0] /\n\t\t\t\t(lastEvent.timeSignature[1] / 4);\n\n\t\t\tlastEvent.measures = lastEvent.measures || 0;\n\t\t\tevent.measures = elapsedMeasures + lastEvent.measures;\n\t\t});\n\t}\n\n\t/**\n\t * Convert ticks into seconds based on the tempo changes.\n\t */\n\tticksToSeconds(ticks: number): number {\n\t\t// Find the relevant position.\n\t\tconst index = search(this.tempos, ticks);\n\n\t\tif (index !== -1) {\n\t\t\tconst tempo = this.tempos[index];\n\t\t\tconst tempoTime = tempo.time;\n\t\t\tconst elapsedBeats = (ticks - tempo.ticks) / this.ppq;\n\n\t\t\treturn tempoTime + (60 / tempo.bpm) * elapsedBeats;\n\t\t} else {\n\t\t\t// Assume 120.\n\t\t\tconst beats = ticks / this.ppq;\n\t\t\treturn (60 / 120) * beats;\n\t\t}\n\t}\n\n\t/**\n\t * Convert ticks into measures based off of the time signatures.\n\t */\n\tticksToMeasures(ticks: number): number {\n\t\tconst index = search(this.timeSignatures, ticks);\n\n\t\tif (index !== -1) {\n\t\t\tconst timeSigEvent = this.timeSignatures[index];\n\t\t\tconst elapsedBeats = (ticks - timeSigEvent.ticks) / this.ppq;\n\n\t\t\treturn (\n\t\t\t\ttimeSigEvent.measures +\n\t\t\t\telapsedBeats /\n\t\t\t\t\t(timeSigEvent.timeSignature[0] /\n\t\t\t\t\t\ttimeSigEvent.timeSignature[1]) /\n\t\t\t\t\t4\n\t\t\t);\n\t\t} else {\n\t\t\treturn ticks / this.ppq / 4;\n\t\t}\n\t}\n\n\t/**\n\t * The number of ticks per quarter note.\n\t */\n\tget ppq(): number {\n\t\treturn privatePPQMap.get(this);\n\t}\n\n\t/**\n\t * Convert seconds to ticks based on the tempo events.\n\t */\n\tsecondsToTicks(seconds: number): number {\n\t\t// Find the relevant position.\n\t\tconst index = search(this.tempos, seconds, \"time\");\n\n\t\tif (index !== -1) {\n\t\t\tconst tempo = this.tempos[index];\n\t\t\tconst tempoTime = tempo.time;\n\t\t\tconst elapsedTime = seconds - tempoTime;\n\t\t\tconst elapsedBeats = elapsedTime / (60 / tempo.bpm);\n\n\t\t\treturn Math.round(tempo.ticks + elapsedBeats * this.ppq);\n\t\t} else {\n\t\t\t// Assume 120.\n\t\t\tconst beats = seconds / (60 / 120);\n\t\t\treturn Math.round(beats * this.ppq);\n\t\t}\n\t}\n\n\t/**\n\t * Convert the header into an object.\n\t */\n\ttoJSON(): HeaderJSON {\n\t\treturn {\n\t\t\tkeySignatures: this.keySignatures,\n\t\t\tmeta: this.meta,\n\t\t\tname: this.name,\n\t\t\tppq: this.ppq,\n\t\t\ttempos: this.tempos.map((t) => {\n\t\t\t\treturn {\n\t\t\t\t\tbpm: t.bpm,\n\t\t\t\t\tticks: t.ticks,\n\t\t\t\t};\n\t\t\t}),\n\t\t\ttimeSignatures: this.timeSignatures,\n\t\t};\n\t}\n\n\t/**\n\t * Parse a header json object.\n\t */\n\tfromJSON(json: HeaderJSON): void {\n\t\tthis.name = json.name;\n\t\t\n\t\t// Clone all the attributes.\n\t\tthis.tempos = json.tempos.map((t) => Object.assign({}, t));\n\t\tthis.timeSignatures = json.timeSignatures.map((t) =>\n\t\t\tObject.assign({}, t)\n\t\t);\n\t\tthis.keySignatures = json.keySignatures.map((t) =>\n\t\t\tObject.assign({}, t)\n\t\t);\n\t\tthis.meta = json.meta.map((t) => Object.assign({}, t));\n\n\t\tprivatePPQMap.set(this, json.ppq);\n\t\tthis.update();\n\t}\n\n\t/**\n\t * Update the tempo of the midi to a single tempo. Will remove and replace\n\t * any other tempos currently set and update all of the event timing.\n\t * @param bpm The tempo in beats per second.\n\t */\n\tsetTempo(bpm: number): void {\n\t\tthis.tempos = [\n\t\t\t{\n\t\t\t\tbpm,\n\t\t\t\tticks: 0,\n\t\t\t},\n\t\t];\n\t\tthis.update();\n\t}\n}\n\nexport interface HeaderJSON {\n\tname: string;\n\tppq: number;\n\tmeta: MetaEvent[];\n\ttempos: TempoEvent[];\n\ttimeSignatures: TimeSignatureEvent[];\n\tkeySignatures: KeySignatureEvent[];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}