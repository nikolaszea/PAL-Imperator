{"ast":null,"code":"// data should be the same type of format returned by parseMidi\n// for maximum compatibililty, returns an array of byte values, suitable for conversion to Buffer, Uint8Array, etc.\n\n// opts:\n// - running              reuse previous eventTypeByte when possible, to compress file\n// - useByte9ForNoteOff   use 0x09 for noteOff when velocity is zero\n\nfunction writeMidi(data, opts) {\n  if (typeof data !== 'object') throw 'Invalid MIDI data';\n  opts = opts || {};\n  var header = data.header || {};\n  var tracks = data.tracks || [];\n  var i,\n    len = tracks.length;\n  var w = new Writer();\n  writeHeader(w, header, len);\n  for (i = 0; i < len; i++) {\n    writeTrack(w, tracks[i], opts);\n  }\n  return w.buffer;\n}\nfunction writeHeader(w, header, numTracks) {\n  var format = header.format == null ? 1 : header.format;\n  var timeDivision = 128;\n  if (header.timeDivision) {\n    timeDivision = header.timeDivision;\n  } else if (header.ticksPerFrame && header.framesPerSecond) {\n    timeDivision = -(header.framesPerSecond & 0xFF) << 8 | header.ticksPerFrame & 0xFF;\n  } else if (header.ticksPerBeat) {\n    timeDivision = header.ticksPerBeat & 0x7FFF;\n  }\n  var h = new Writer();\n  h.writeUInt16(format);\n  h.writeUInt16(numTracks);\n  h.writeUInt16(timeDivision);\n  w.writeChunk('MThd', h.buffer);\n}\nfunction writeTrack(w, track, opts) {\n  var t = new Writer();\n  var i,\n    len = track.length;\n  var eventTypeByte = null;\n  for (i = 0; i < len; i++) {\n    // Reuse last eventTypeByte when opts.running is set, or event.running is explicitly set on it.\n    // parseMidi will set event.running for each event, so that we can get an exact copy by default.\n    // Explicitly set opts.running to false, to override event.running and never reuse last eventTypeByte.\n    if (opts.running === false || !opts.running && !track[i].running) eventTypeByte = null;\n    eventTypeByte = writeEvent(t, track[i], eventTypeByte, opts.useByte9ForNoteOff);\n  }\n  w.writeChunk('MTrk', t.buffer);\n}\nfunction writeEvent(w, event, lastEventTypeByte, useByte9ForNoteOff) {\n  var type = event.type;\n  var deltaTime = event.deltaTime;\n  var text = event.text || '';\n  var data = event.data || [];\n  var eventTypeByte = null;\n  w.writeVarInt(deltaTime);\n  switch (type) {\n    // meta events\n    case 'sequenceNumber':\n      w.writeUInt8(0xFF);\n      w.writeUInt8(0x00);\n      w.writeVarInt(2);\n      w.writeUInt16(event.number);\n      break;\n    case 'text':\n      w.writeUInt8(0xFF);\n      w.writeUInt8(0x01);\n      w.writeVarInt(text.length);\n      w.writeString(text);\n      break;\n    case 'copyrightNotice':\n      w.writeUInt8(0xFF);\n      w.writeUInt8(0x02);\n      w.writeVarInt(text.length);\n      w.writeString(text);\n      break;\n    case 'trackName':\n      w.writeUInt8(0xFF);\n      w.writeUInt8(0x03);\n      w.writeVarInt(text.length);\n      w.writeString(text);\n      break;\n    case 'instrumentName':\n      w.writeUInt8(0xFF);\n      w.writeUInt8(0x04);\n      w.writeVarInt(text.length);\n      w.writeString(text);\n      break;\n    case 'lyrics':\n      w.writeUInt8(0xFF);\n      w.writeUInt8(0x05);\n      w.writeVarInt(text.length);\n      w.writeString(text);\n      break;\n    case 'marker':\n      w.writeUInt8(0xFF);\n      w.writeUInt8(0x06);\n      w.writeVarInt(text.length);\n      w.writeString(text);\n      break;\n    case 'cuePoint':\n      w.writeUInt8(0xFF);\n      w.writeUInt8(0x07);\n      w.writeVarInt(text.length);\n      w.writeString(text);\n      break;\n    case 'channelPrefix':\n      w.writeUInt8(0xFF);\n      w.writeUInt8(0x20);\n      w.writeVarInt(1);\n      w.writeUInt8(event.channel);\n      break;\n    case 'portPrefix':\n      w.writeUInt8(0xFF);\n      w.writeUInt8(0x21);\n      w.writeVarInt(1);\n      w.writeUInt8(event.port);\n      break;\n    case 'endOfTrack':\n      w.writeUInt8(0xFF);\n      w.writeUInt8(0x2F);\n      w.writeVarInt(0);\n      break;\n    case 'setTempo':\n      w.writeUInt8(0xFF);\n      w.writeUInt8(0x51);\n      w.writeVarInt(3);\n      w.writeUInt24(event.microsecondsPerBeat);\n      break;\n    case 'smpteOffset':\n      w.writeUInt8(0xFF);\n      w.writeUInt8(0x54);\n      w.writeVarInt(5);\n      var FRAME_RATES = {\n        24: 0x00,\n        25: 0x20,\n        29: 0x40,\n        30: 0x60\n      };\n      var hourByte = event.hour & 0x1F | FRAME_RATES[event.frameRate];\n      w.writeUInt8(hourByte);\n      w.writeUInt8(event.min);\n      w.writeUInt8(event.sec);\n      w.writeUInt8(event.frame);\n      w.writeUInt8(event.subFrame);\n      break;\n    case 'timeSignature':\n      w.writeUInt8(0xFF);\n      w.writeUInt8(0x58);\n      w.writeVarInt(4);\n      w.writeUInt8(event.numerator);\n      var denominator = Math.floor(Math.log(event.denominator) / Math.LN2) & 0xFF;\n      w.writeUInt8(denominator);\n      w.writeUInt8(event.metronome);\n      w.writeUInt8(event.thirtyseconds || 8);\n      break;\n    case 'keySignature':\n      w.writeUInt8(0xFF);\n      w.writeUInt8(0x59);\n      w.writeVarInt(2);\n      w.writeInt8(event.key);\n      w.writeUInt8(event.scale);\n      break;\n    case 'sequencerSpecific':\n      w.writeUInt8(0xFF);\n      w.writeUInt8(0x7F);\n      w.writeVarInt(data.length);\n      w.writeBytes(data);\n      break;\n    case 'unknownMeta':\n      if (event.metatypeByte != null) {\n        w.writeUInt8(0xFF);\n        w.writeUInt8(event.metatypeByte);\n        w.writeVarInt(data.length);\n        w.writeBytes(data);\n      }\n      break;\n\n    // system-exclusive\n    case 'sysEx':\n      w.writeUInt8(0xF0);\n      w.writeVarInt(data.length);\n      w.writeBytes(data);\n      break;\n    case 'endSysEx':\n      w.writeUInt8(0xF7);\n      w.writeVarInt(data.length);\n      w.writeBytes(data);\n      break;\n\n    // channel events\n    case 'noteOff':\n      // Use 0x90 when opts.useByte9ForNoteOff is set and velocity is zero, or when event.byte9 is explicitly set on it.\n      // parseMidi will set event.byte9 for each event, so that we can get an exact copy by default.\n      // Explicitly set opts.useByte9ForNoteOff to false, to override event.byte9 and always use 0x80 for noteOff events.\n      var noteByte = useByte9ForNoteOff !== false && event.byte9 || useByte9ForNoteOff && event.velocity == 0 ? 0x90 : 0x80;\n      eventTypeByte = noteByte | event.channel;\n      if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte);\n      w.writeUInt8(event.noteNumber);\n      w.writeUInt8(event.velocity);\n      break;\n    case 'noteOn':\n      eventTypeByte = 0x90 | event.channel;\n      if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte);\n      w.writeUInt8(event.noteNumber);\n      w.writeUInt8(event.velocity);\n      break;\n    case 'noteAftertouch':\n      eventTypeByte = 0xA0 | event.channel;\n      if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte);\n      w.writeUInt8(event.noteNumber);\n      w.writeUInt8(event.amount);\n      break;\n    case 'controller':\n      eventTypeByte = 0xB0 | event.channel;\n      if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte);\n      w.writeUInt8(event.controllerType);\n      w.writeUInt8(event.value);\n      break;\n    case 'programChange':\n      eventTypeByte = 0xC0 | event.channel;\n      if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte);\n      w.writeUInt8(event.programNumber);\n      break;\n    case 'channelAftertouch':\n      eventTypeByte = 0xD0 | event.channel;\n      if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte);\n      w.writeUInt8(event.amount);\n      break;\n    case 'pitchBend':\n      eventTypeByte = 0xE0 | event.channel;\n      if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte);\n      var value14 = 0x2000 + event.value;\n      var lsb14 = value14 & 0x7F;\n      var msb14 = value14 >> 7 & 0x7F;\n      w.writeUInt8(lsb14);\n      w.writeUInt8(msb14);\n      break;\n    default:\n      throw 'Unrecognized event type: ' + type;\n  }\n  return eventTypeByte;\n}\nfunction Writer() {\n  this.buffer = [];\n}\nWriter.prototype.writeUInt8 = function (v) {\n  this.buffer.push(v & 0xFF);\n};\nWriter.prototype.writeInt8 = Writer.prototype.writeUInt8;\nWriter.prototype.writeUInt16 = function (v) {\n  var b0 = v >> 8 & 0xFF,\n    b1 = v & 0xFF;\n  this.writeUInt8(b0);\n  this.writeUInt8(b1);\n};\nWriter.prototype.writeInt16 = Writer.prototype.writeUInt16;\nWriter.prototype.writeUInt24 = function (v) {\n  var b0 = v >> 16 & 0xFF,\n    b1 = v >> 8 & 0xFF,\n    b2 = v & 0xFF;\n  this.writeUInt8(b0);\n  this.writeUInt8(b1);\n  this.writeUInt8(b2);\n};\nWriter.prototype.writeInt24 = Writer.prototype.writeUInt24;\nWriter.prototype.writeUInt32 = function (v) {\n  var b0 = v >> 24 & 0xFF,\n    b1 = v >> 16 & 0xFF,\n    b2 = v >> 8 & 0xFF,\n    b3 = v & 0xFF;\n  this.writeUInt8(b0);\n  this.writeUInt8(b1);\n  this.writeUInt8(b2);\n  this.writeUInt8(b3);\n};\nWriter.prototype.writeInt32 = Writer.prototype.writeUInt32;\nWriter.prototype.writeBytes = function (arr) {\n  this.buffer = this.buffer.concat(Array.prototype.slice.call(arr, 0));\n};\nWriter.prototype.writeString = function (str) {\n  var i,\n    len = str.length,\n    arr = [];\n  for (i = 0; i < len; i++) {\n    arr.push(str.codePointAt(i));\n  }\n  this.writeBytes(arr);\n};\nWriter.prototype.writeVarInt = function (v) {\n  if (v < 0) throw \"Cannot write negative variable-length integer\";\n  if (v <= 0x7F) {\n    this.writeUInt8(v);\n  } else {\n    var i = v;\n    var bytes = [];\n    bytes.push(i & 0x7F);\n    i >>= 7;\n    while (i) {\n      var b = i & 0x7F | 0x80;\n      bytes.push(b);\n      i >>= 7;\n    }\n    this.writeBytes(bytes.reverse());\n  }\n};\nWriter.prototype.writeChunk = function (id, data) {\n  this.writeString(id);\n  this.writeUInt32(data.length);\n  this.writeBytes(data);\n};\nmodule.exports = writeMidi;","map":{"version":3,"names":["writeMidi","data","opts","header","tracks","i","len","length","w","Writer","writeHeader","writeTrack","buffer","numTracks","format","timeDivision","ticksPerFrame","framesPerSecond","ticksPerBeat","h","writeUInt16","writeChunk","track","t","eventTypeByte","running","writeEvent","useByte9ForNoteOff","event","lastEventTypeByte","type","deltaTime","text","writeVarInt","writeUInt8","number","writeString","channel","port","writeUInt24","microsecondsPerBeat","FRAME_RATES","hourByte","hour","frameRate","min","sec","frame","subFrame","numerator","denominator","Math","floor","log","LN2","metronome","thirtyseconds","writeInt8","key","scale","writeBytes","metatypeByte","noteByte","byte9","velocity","noteNumber","amount","controllerType","value","programNumber","value14","lsb14","msb14","prototype","v","push","b0","b1","writeInt16","b2","writeInt24","writeUInt32","b3","writeInt32","arr","concat","Array","slice","call","str","codePointAt","bytes","b","reverse","id","module","exports"],"sources":["/Users/niko/Documents/PAL-Imperator/node_modules/midi-file/lib/midi-writer.js"],"sourcesContent":["// data should be the same type of format returned by parseMidi\n// for maximum compatibililty, returns an array of byte values, suitable for conversion to Buffer, Uint8Array, etc.\n\n// opts:\n// - running              reuse previous eventTypeByte when possible, to compress file\n// - useByte9ForNoteOff   use 0x09 for noteOff when velocity is zero\n\nfunction writeMidi(data, opts) {\n  if (typeof data !== 'object')\n    throw 'Invalid MIDI data'\n\n  opts = opts || {}\n\n  var header = data.header || {}\n  var tracks = data.tracks || []\n  var i, len = tracks.length\n\n  var w = new Writer()\n  writeHeader(w, header, len)\n\n  for (i=0; i < len; i++) {\n    writeTrack(w, tracks[i], opts)\n  }\n\n  return w.buffer\n}\n\nfunction writeHeader(w, header, numTracks) {\n  var format = header.format == null ? 1 : header.format\n\n  var timeDivision = 128\n  if (header.timeDivision) {\n    timeDivision = header.timeDivision\n  } else if (header.ticksPerFrame && header.framesPerSecond) {\n    timeDivision = (-(header.framesPerSecond & 0xFF) << 8) | (header.ticksPerFrame & 0xFF)\n  } else if (header.ticksPerBeat) {\n    timeDivision = header.ticksPerBeat & 0x7FFF\n  }\n\n  var h = new Writer()\n  h.writeUInt16(format)\n  h.writeUInt16(numTracks)\n  h.writeUInt16(timeDivision)\n\n  w.writeChunk('MThd', h.buffer)\n}\n\nfunction writeTrack(w, track, opts) {\n  var t = new Writer()\n  var i, len = track.length\n  var eventTypeByte = null\n  for (i=0; i < len; i++) {\n    // Reuse last eventTypeByte when opts.running is set, or event.running is explicitly set on it.\n    // parseMidi will set event.running for each event, so that we can get an exact copy by default.\n    // Explicitly set opts.running to false, to override event.running and never reuse last eventTypeByte.\n    if (opts.running === false || !opts.running && !track[i].running) eventTypeByte = null\n\n    eventTypeByte = writeEvent(t, track[i], eventTypeByte, opts.useByte9ForNoteOff)\n  }\n  w.writeChunk('MTrk', t.buffer)\n}\n\nfunction writeEvent(w, event, lastEventTypeByte, useByte9ForNoteOff) {\n  var type = event.type\n  var deltaTime = event.deltaTime\n  var text = event.text || ''\n  var data = event.data || []\n  var eventTypeByte = null\n  w.writeVarInt(deltaTime)\n\n  switch (type) {\n    // meta events\n    case 'sequenceNumber':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x00)\n      w.writeVarInt(2)\n      w.writeUInt16(event.number)\n      break;\n\n    case 'text':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x01)\n      w.writeVarInt(text.length)\n      w.writeString(text)\n      break;\n\n    case 'copyrightNotice':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x02)\n      w.writeVarInt(text.length)\n      w.writeString(text)\n      break;\n\n    case 'trackName':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x03)\n      w.writeVarInt(text.length)\n      w.writeString(text)\n      break;\n\n    case 'instrumentName':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x04)\n      w.writeVarInt(text.length)\n      w.writeString(text)\n      break;\n\n    case 'lyrics':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x05)\n      w.writeVarInt(text.length)\n      w.writeString(text)\n      break;\n\n    case 'marker':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x06)\n      w.writeVarInt(text.length)\n      w.writeString(text)\n      break;\n\n    case 'cuePoint':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x07)\n      w.writeVarInt(text.length)\n      w.writeString(text)\n      break;\n\n    case 'channelPrefix':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x20)\n      w.writeVarInt(1)\n      w.writeUInt8(event.channel)\n      break;\n\n    case 'portPrefix':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x21)\n      w.writeVarInt(1)\n      w.writeUInt8(event.port)\n      break;\n\n    case 'endOfTrack':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x2F)\n      w.writeVarInt(0)\n      break;\n\n    case 'setTempo':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x51)\n      w.writeVarInt(3)\n      w.writeUInt24(event.microsecondsPerBeat)\n      break;\n\n    case 'smpteOffset':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x54)\n      w.writeVarInt(5)\n      var FRAME_RATES = { 24: 0x00, 25: 0x20, 29: 0x40, 30: 0x60 }\n      var hourByte = (event.hour & 0x1F) | FRAME_RATES[event.frameRate]\n      w.writeUInt8(hourByte)\n      w.writeUInt8(event.min)\n      w.writeUInt8(event.sec)\n      w.writeUInt8(event.frame)\n      w.writeUInt8(event.subFrame)\n      break;\n\n    case 'timeSignature':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x58)\n      w.writeVarInt(4)\n      w.writeUInt8(event.numerator)\n      var denominator = Math.floor((Math.log(event.denominator) / Math.LN2)) & 0xFF\n      w.writeUInt8(denominator)\n      w.writeUInt8(event.metronome)\n      w.writeUInt8(event.thirtyseconds || 8)\n      break;\n\n    case 'keySignature':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x59)\n      w.writeVarInt(2)\n      w.writeInt8(event.key)\n      w.writeUInt8(event.scale)\n      break;\n\n    case 'sequencerSpecific':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x7F)\n      w.writeVarInt(data.length)\n      w.writeBytes(data)\n      break;\n\n    case 'unknownMeta':\n      if (event.metatypeByte != null) {\n        w.writeUInt8(0xFF)\n        w.writeUInt8(event.metatypeByte)\n        w.writeVarInt(data.length)\n        w.writeBytes(data)\n      }\n      break;\n\n    // system-exclusive\n    case 'sysEx':\n      w.writeUInt8(0xF0)\n      w.writeVarInt(data.length)\n      w.writeBytes(data)\n      break;\n\n    case 'endSysEx':\n      w.writeUInt8(0xF7)\n      w.writeVarInt(data.length)\n      w.writeBytes(data)\n      break;\n\n    // channel events\n    case 'noteOff':\n      // Use 0x90 when opts.useByte9ForNoteOff is set and velocity is zero, or when event.byte9 is explicitly set on it.\n      // parseMidi will set event.byte9 for each event, so that we can get an exact copy by default.\n      // Explicitly set opts.useByte9ForNoteOff to false, to override event.byte9 and always use 0x80 for noteOff events.\n      var noteByte = ((useByte9ForNoteOff !== false && event.byte9) || (useByte9ForNoteOff && event.velocity == 0)) ? 0x90 : 0x80\n\n      eventTypeByte = noteByte | event.channel\n      if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte)\n      w.writeUInt8(event.noteNumber)\n      w.writeUInt8(event.velocity)\n      break;\n\n    case 'noteOn':\n      eventTypeByte = 0x90 | event.channel\n      if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte)\n      w.writeUInt8(event.noteNumber)\n      w.writeUInt8(event.velocity)\n      break;\n\n    case 'noteAftertouch':\n      eventTypeByte = 0xA0 | event.channel\n      if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte)\n      w.writeUInt8(event.noteNumber)\n      w.writeUInt8(event.amount)\n      break;\n\n    case 'controller':\n      eventTypeByte = 0xB0 | event.channel\n      if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte)\n      w.writeUInt8(event.controllerType)\n      w.writeUInt8(event.value)\n      break;\n\n    case 'programChange':\n      eventTypeByte = 0xC0 | event.channel\n      if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte)\n      w.writeUInt8(event.programNumber)\n      break;\n\n    case 'channelAftertouch':\n      eventTypeByte = 0xD0 | event.channel\n      if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte)\n      w.writeUInt8(event.amount)\n      break;\n\n    case 'pitchBend':\n      eventTypeByte = 0xE0 | event.channel\n      if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte)\n      var value14 = 0x2000 + event.value\n      var lsb14 = (value14 & 0x7F)\n      var msb14 = (value14 >> 7) & 0x7F\n      w.writeUInt8(lsb14)\n      w.writeUInt8(msb14)\n    break;\n\n    default:\n      throw 'Unrecognized event type: ' + type\n  }\n  return eventTypeByte\n}\n\n\nfunction Writer() {\n  this.buffer = []\n}\n\nWriter.prototype.writeUInt8 = function(v) {\n  this.buffer.push(v & 0xFF)\n}\nWriter.prototype.writeInt8 = Writer.prototype.writeUInt8\n\nWriter.prototype.writeUInt16 = function(v) {\n  var b0 = (v >> 8) & 0xFF,\n      b1 = v & 0xFF\n\n  this.writeUInt8(b0)\n  this.writeUInt8(b1)\n}\nWriter.prototype.writeInt16 = Writer.prototype.writeUInt16\n\nWriter.prototype.writeUInt24 = function(v) {\n  var b0 = (v >> 16) & 0xFF,\n      b1 = (v >> 8) & 0xFF,\n      b2 = v & 0xFF\n\n  this.writeUInt8(b0)\n  this.writeUInt8(b1)\n  this.writeUInt8(b2)\n}\nWriter.prototype.writeInt24 = Writer.prototype.writeUInt24\n\nWriter.prototype.writeUInt32 = function(v) {\n  var b0 = (v >> 24) & 0xFF,\n      b1 = (v >> 16) & 0xFF,\n      b2 = (v >> 8) & 0xFF,\n      b3 = v & 0xFF\n\n  this.writeUInt8(b0)\n  this.writeUInt8(b1)\n  this.writeUInt8(b2)\n  this.writeUInt8(b3)\n}\nWriter.prototype.writeInt32 = Writer.prototype.writeUInt32\n\n\nWriter.prototype.writeBytes = function(arr) {\n  this.buffer = this.buffer.concat(Array.prototype.slice.call(arr, 0))\n}\n\nWriter.prototype.writeString = function(str) {\n  var i, len = str.length, arr = []\n  for (i=0; i < len; i++) {\n    arr.push(str.codePointAt(i))\n  }\n  this.writeBytes(arr)\n}\n\nWriter.prototype.writeVarInt = function(v) {\n  if (v < 0) throw \"Cannot write negative variable-length integer\"\n\n  if (v <= 0x7F) {\n    this.writeUInt8(v)\n  } else {\n    var i = v\n    var bytes = []\n    bytes.push(i & 0x7F)\n    i >>= 7\n    while (i) {\n      var b = i & 0x7F | 0x80\n      bytes.push(b)\n      i >>= 7\n    }\n    this.writeBytes(bytes.reverse())\n  }\n}\n\nWriter.prototype.writeChunk = function(id, data) {\n  this.writeString(id)\n  this.writeUInt32(data.length)\n  this.writeBytes(data)\n}\n\nmodule.exports = writeMidi\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}